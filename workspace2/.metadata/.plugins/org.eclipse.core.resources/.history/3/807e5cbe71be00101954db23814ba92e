/*
--------- Auf Das  ---------
------- Filter IIR  -------
-------- 30/10/2025 --------

*/
// ------- Main Library -------
#include "conf.h"
#include <stm32f446xx.h>

// --------- Function ---------
void confRCC(void);
void confGPIO(void);
// ---------- Class ----------
// -------- Variables --------
// ----------- Main -----------
void conv(uint16_t*, const double*);
const double h[21] = {
    0,
    0.0008661866575345,
    -1.862664770708e-18,
    0.009379606223572,
    6.739184450067e-18,
    0.03185584403768,
    -1.276689426737e-17,
    0.08430039893725,
    1.764341394673e-17,
    0.310762760459,
    0.5003904280133,
    0.310762760459,
    1.764341394673e-17,
    -0.08430039893725,
    -1.276689426737e-17,
    0.03185584403768,
    6.739184450067e-18,
    -0.009379606223572,
    -1.862664770708e-18,
    0.0008661866575345,
    0
};
uint8_t i=0;
#define samples 21
uint16_t smplVEC[samples];
uint16_t out[samples];
uint8_t state=0;
uint8_t j=0;
int main(void){
    config();


    while(1);
}

/*

conv(smplVEC, h);            
0 Data Capture and Convolve
1 Data Output
*/


void TIM2_IRQHandler(void){
    if (TIM2->SR & (1<<0))
	{
        switch (state){
            case 0:
                if(i<samples){
                    smplVEC[i]=ADC1->DR; i++;}
                else{
                conv(smplVEC, h);            
                i=0; state=1;
                //TIM2->ARR  =20;// 1.6M*(1/80K) FREC DE MUESTREO DE 40KHZ
                }
                break;
            case 1:
                DAC->DHR12R1=(out[j]);
                DAC->SWTRIGR|=(1<<0);
                j++;
                if (j>=samples-1) {
                  //  TIM2->ARR  =40;
                    state =0;
                }
                break;
            }
        }
        TIM2->SR &= ~(1<<0); // limpia UIF
}

void conv(uint16_t *x, const double *h){

	//Filter Shifted, Signal Fixed
	
    for(uint8_t n = 0; n < samples; n++){
        out[n] = 0;  // limpia acumulador

        for(uint8_t k = 0; k < n+1; k++){
                out[n] += (uint16_t)(x[k] * (h[n-k]));
        }
    }
}
